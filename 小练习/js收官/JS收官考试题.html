<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- <style>
        .pp {
            background-color: fuchsia;
        }

        #p {
            background-color: gold;
        }
    </style> -->
</head>

<body>

    <!-- <p class="pp">1234</p>
    <p id="p">5678</p>
    <p>90</p> -->
    <script>

        // 1.// 定义数组：var arr = [{name: 'cst', age: '18'}, {name: 'jc', age: '20'}, {name: 'dxm', age: '50'} , {name: 'dcg', age: '30'}]。利用filter和map对数组进行操作：留下name中包含c的，并且让他们的年龄都乘2。
        // var arr = [{
        //     name: 'cst',
        //     age: '18'
        // }, {
        //     name: 'jc',
        //     age: '20'
        // }, {
        //     name: 'dxm',
        //     age: '50'
        // }, {
        //     name: 'dcg',
        //     age: '30'
        // }]

        // var newArr = arr.filter(function (ele, index, self) {
        //     if (ele.name.includes('c')) {
        //         return true;
        //     } else {
        //         return false;
        //     }
        // })

        // var addArr = arr.map(function (ele, index, self) {
        //     ele.age = parseInt(ele.age) * 2;
        //     return ele.age;
        // })

        // console.log(newArr, addArr);

        // 2. 用你能想到较好的，且通用方式把浏览器输入框上的网址，如：https://www.baidu.com/s?ie=utf-8&f=8。按以下几个部分划分并且创建对象：
        // ○ 协议：https  
        // ○ 主机：www.baidu.com 
        // ○ 路径：/s 
        // ○ 参数：ie=utf-8&f=8
        //  此对象属性和属性值形式如下：
        // {
        //     protocol: 'https',
        //         host：'www.baidu.com',
        //             path: '/s',
        //                 search: { ie: 'utf-8', f: '8' }
        // }

        // (1) 
        // var url = new URL('https://www.baidu.com/s?ie=utf-8&f=8');
        // function getUrlObj() {
        //     var result = {
        //         protocol: url.protocol,
        //         host: url.hostname,
        //         path: url.pathname,
        //         search: {},
        //     }

        //     var str = url.search.substr(1);
        //     var param = str.split('&');

        //     param.reduce(function (pre, cur) {
        //         var items = cur.split('=');
        //         pre[items[0]] = items[1];
        //         return pre;
        //     }, result.search);
        //     console.log(result);
        // }

        // getUrlObj();

        // (2) 
        // var url = new URL('https://www.baidu.com/s?ie=utf-8&f=8');
        // function getUrlObj() {
        //     var result = {
        //         protocol: url.protocol,
        //         host: url.hostname,
        //         path: url.pathname,
        //         search: {},
        //     }
        //     for (param of url.searchParams) {
        //         result.search[param[0]] = param[1];
        //     }
        //     console.log(result);
        // }
        // getUrlObj();

        // 3. 实现一个getDom(str)函数，可以根据参数（str形式如：'#id'、'.Class'、'tag'）的不同选择对应选择不同的dom。 
        //     注：
        //     ○ '#id'此参数为根据id名称选择dom，.Class此参数为根据类名选择dom，'tag'此参数为根据标签名称获取dom。
        //     ○ 不能使用原生的getElementsByClassName方法
        // [ function getClassName(_className){
        //     //_className
        //     //获取document下面的标签
        //     var allDomArray = document.getElementsByTagName('*');
        //     var lastDomArray = [];

        //     function trimSpace (strClass) {
        //         var reg = /\s+/g;
        //         var newStrClass = strClass.className.replace(reg, ' ');
        //         return newStrClass;
        //     }
        //     for(var i = 0; i < allDomArray.length; i ++){
        //         var lastStrClass = trimSpace(allDomArray[i]).trim();
        //         var classArray = lastStrClass.split(' ');
        //         // console.log(classArray)
        //         for(var j = 0; j < classArray.length; j ++) {
        //             if(classArray[j] == _className) {
        //                 lastDomArray.push(allDomArray[i]);
        //                 break;
        //             }
        //         }
        //     }
        //     return lastDomArray;
        // }
        // function getDom(selector){
        //     this.length = 0;
        //     var dom = null;
        //     if(selector.indexOf('.') != -1){
        //         dom = getClassName(selector.slice(1));
        //     } else if(selector.indexOf('#') != -1){
        //         dom = document.getElementById(selector.slice(1));
        //     } else{
        //         dom = document.getElementsByTagName(selector);
        //     }
        //     return dom;
        // } ]（有问题）

        // [ function trimClassName(dom) {
        //     var reg = /\s+/g;
        //     // 把所有的空格变成一个先
        //     var newClassStr = dom.className.replace(reg, ' ');
        //     return newClassStr;
        // };
        //     //创建一个获取class元素方法
        //     function getByClass(_className) {
        //         var allDomArray = [].slice.call(document.getElementsByTagName('*'), 0);
        //         //slice()通过索引位置获取新的数组，该方法不会修改原数组，只是返回一个新的子数组。
        //         //getElementsByTagName()可以根据 标签名 获取一组元素节点对象，
        //         var newDomArr = [];//创建新dom方法
        //         allDomArray.forEach(function (ele, index) {
        //             var newClassStr = trimClassName(ele).trim();//trim()删除左右两端的空格
        //             var classNameArray = newClassStr.split(' ');
        //             classNameArray.forEach(function (className, index) {
        //                 if (className == _className) {
        //                     newDomArr.push(ele);
        //                 }
        //             })
        //         });
        //         return newDomArr;
        //     };

        //     function getDom(selector) {
        //         this.length = 0;
        //         if (selector.indexOf('.') != -1) {
        //             var dom = getByClass(selector.slice(1));
        //         } else if (selector.indexOf('#') != -1) {
        //             var dom = document.getElementById(selector.slice(1));
        //         } else {
        //             var dom = document.getElementsByTagName(selector);
        //         }
        //         return dom;
        //     } ; ]（有问题）

        // 4. 请尝试写出缓冲运动的效果
        // function startMove(dom, target) {
        //     clearInterval(timer);
        //     var iSpeed = null;
        //     timer = setInterval(function () {
        //         iSpeed = (target - dom.offsetLeft) / 7;
        //         iSpeed = iSpeed > 0 ? Math.ceil(iSpeed) : Math.floor(iSpeed);
        //         if (dom.offsetLeft == target) {
        //             clearInterval(timer);
        //         } else {
        //             dom.style.left = dom.offsetLeft + iSpeed + 'px';
        //         }
        //     }, 30);
        // };

        // 5. 请用伪代码（用中文分步描述逻辑）写出轮播图的制作思路
        // a.布局 需要 overflow: hidden的标签（div），内部有ul且宽度足够容纳多个li：float变成一横排。
        // b.引入之前的运动函数配合完成操作。
        // c.用一个定时器控制时间间隔，利用运动函数让ul当前当前位置发生改变，每次移动一个li或最外侧div的宽度。
        // d.添加左右点击事件，通过计算移动方向和移动距离控制ul左右移动
        // e.利用闭包原理给每一个索引按钮绑定事件，事件处理函数可以根据当前索引值决定ul移动到哪个位置上。

    </script>
</body>
</html>